% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select.R
\name{select}
\alias{select}
\title{SQL like select function with internal "where" and "by" features}
\usage{
select(d, ..., where = NULL, by = NULL)
}
\arguments{
\item{d}{data.frame}

\item{...}{'what' arguments: a collection of column names (or colums definitions). See examples below}

\item{where}{boolean condition on columns, under the form cond1 if only one condition, and c(cond1, cond2, ...) if more than one condition}

\item{by}{collection of columns, under the form col1 if only one condition, and c(col1, col2, ...) if more than one column}
}
\value{
selected data.frame
}
\description{
SQL like select function with internal "where" and "by" features
}
\examples{

d <- data.frame(
date=seq(as.Date("2001-01-01"), as.Date("2001-10-01"), by="month"),
ticker=sample(c("1 HK", "2 HK"), 10, TRUE),
ret1=rnorm(10),
ret2=rnorm(10),
ret3=rnorm(10)
)

#The syntax is similar to that of **dplyr**.

d \%>\% select(date, ret1)

d \%>\% select(-date)

#We can also select by giving a vector/list of strings:

d \%>\% select(c("ret1", "ret2", "date"))

#**Be careful**: the name of a column in d **always masks** any variable in the global environment, hence:

mycols <- c("ret1", "ticker")
d \%>\% select(mycols)

#works, but
ret2 <- c("ret1", "ticker")
d \%>\% select(ret2)

#does not yield the expected result (or rather, you should expect to obtain the above result!). **where** and **by** options work as follows.

d \%>\% select(ret1 = mean(ret1), where = c(ret1 >0, ret2>0), by = ticker)

}
